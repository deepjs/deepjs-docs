<div>
    <div id="submenu">
        <h2>Promises</h2>
        <div class="submenu-block" dp-control="js::/js/sub-nav.js">
            <ul>
                <li><a href="#intro">intro</a></li>
                <li><a href="#done"></a>.done()</li>
                <li><a href="#fail"></a>.fail()</li>
                <li><a href="#return-rule">Return rule</a></li>
                <li><a href="#api">API</a>
                    <ul>
                        <li><a href="#always">.always()</a></li>    
                        <li><a href="#always">.always()</a></li>    
                    </ul>
                </li>

                <li><a href="#this">this</a></li>
                <li><a href="#state">state</a></li>
                <li><a href="#context">context</a></li>
            </ul>
        </div>
    </div>
    <div id="content">
        <div class="content">
        	<h3 id="intro">Intro</h3>
<div class="dp-example">
                <pre dp-try class="dp-box code">
// async simulation
var def = deep.Deferred();
setTimeout(function(){
	def.resolve("yes");
}, 50);
var promise = def.promise();

deep.when(promise)
.done(function(success){
	deep.log("success : ", success);
})
.fail(function(error){
	deep.error("error : ", success);
});
                </pre></div>
<p>A Promise manage asynchronously (or not) success or error (its state) through chained notation.</p>

<p>More exactly, a deep-promise, as all promises, is a chain handler that inject a result (a success) or an error in chained callbacks, and manage callbacks response (maybe asynchronously) and use it to define it new state, that could be forwarded to more chained callbacks.</p>

<p>Fondamentaly, there is two kinds of callback familly : </p>

<ul>
<li> .done(function(success){}) : callback will only be fired if promise state is a success</li>
<li> .fail(function(error){}) : callback will only be fired if promise state is an error</li>
</ul>
<p>Those two families could be used together with .then( doneCallBack, failCallBack ), which is exactly the same as doing .done(callBack).fail(callback)</p>

<p>The big difference from simple callback pattern (as nodejs abuse), is that the promise continue to hold its state, long time after primary events, and provides way (when adding a new callback when needed) to get its state at any time after primary events.</p>


<h3 id="return-rule">Callbacks Return Rule</h3>

<p>if returned value is :</p>

<ul>
<li>undefined : take previous success or error (so it does not modify current promise state)</li>
<li>an error : inject error as failure in chain (so change state to 'error')</li>
<li>a promise : wait promise resolution to either inject its success or its error in current chain.</li>
<li>a deep.Undefined : it will force 'undefined' injection in chain.</li>
<li>any other type : inject it as success in chain (so if the promise was in 'error' state : it's now in 'success' state)</li>
</ul>
<p>if an error is thrown : from within any handle : it depends if chain catch errors (by default, it catch them).
</p>
<p><span class="label label-info">Remarque</span> that's true for both done and fail families. </p>
<p>That implied that you could always catch and handles errors produced within any callbacks with a .fail(callback) placed after in chain (that will be fired as promise state is error), and then return (in the fail callback) something that's not an Error, and so reset current promise state to success.</p>

            <div class="dp-example">
                <pre dp-try class="dp-box code">
deep.when(new Error("hello error"))
.done(function(success){
	// this callback will simply be ignored, as promise state is 'error'.
	// ...
})
.fail(function(e){
	// this one will be fired as promise state is 'error'
	// but as it return nothing (so undefined), it does not modifiy promise state.
	deep.log("error : ", e.toString());
})
.fail(function(e){    // also fired as promise state stills 'error'.
	return "error handled : continue chain";
})
.done(function(success){ 	// this one will be fired, as state has been reseted to 'success'
	deep.log("success : ", success);
});
</pre></div>
		</div>
        <div class="content">

<h3 id="catchErrors">.catchErrors( bool )</h3>

<p>set if promise catches or not errors produced within callback. promises catch them by default.</p>

<h3 id="always">.always(function(success, error){})</h3>

<p>will always be executed.</p>

<h3 id="log">.log()</h3>

<p>will always be executed.</p>

if you provide no arguments :
will log current state. (success or error)
if you provide a list of arguments (i.e. .log(arg1, "hello", myObject, 12, ...)), it will print them as deep log would do.
            <div class="dp-example">
                <pre dp-try class="dp-box code">
deep.when(true)
.log("hello", "john", ":");
</pre></div>

It does not modifiy promise state.

<h3 id="equal">.equal( obj )</h3>

Executed only if promise is in success state.

Test success struct equality to obj. Useful for testcasing.

If not equal, it inject a PreconditionFailed error (status 412) in promise, with equality report.

If equal : it does not modifiy promise state.

<h3 id="when">.when( something )</h3>

Not exactly the same thing as deep.when( something ) that return a promise that waiting 'something' (you start a promise as this),
when you use it in an existant promise chain, it will wait 'something' and take it result as current state before continuing.

            <div class="dp-example">
                <pre dp-try class="dp-box code">
deep.when( something )
.done(function( somethingResult ))
.when( anotherthing )
.done(function( anotherthingResult ){
	...
});
</pre></div>

<h3 id="delay">.delay( ms )</h3>

executed only in success state.
Add an artifical delay in chain execution. useful for test and debug.


<h3 id="to-context">.toContext(key, value)</h3>

For painless asynchrone context management. (thanx [Kris](https://github.com/kriszyp) ! ;)
Set in local deep.context the provided value under 'key'.
See [asynch-context-management](./asynch-context-management.md) for more details.


<h3 id="clog">.clog()</h3>

same thing as .log() above.
But log current context in place of promise state.
it does not modifiy promise state.

<h3 id="deferred"> Deferred</h3>

How to use deferred.

<h3 id="when">deep.when</h3>

<h3 id="all">deep.all</h3>



		</div>
	</div>
</div>



